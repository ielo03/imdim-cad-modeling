#!/usr/bin/env python3
"""Generate SCAD programs for dataset/train/all_openscad and ast_only."""

import os
import json
import random
from pathlib import Path
import sys

# ensure project root on sys.path for local import
ROOT = Path(__file__).resolve().parents[2]
sys.path.insert(0, str(ROOT))

from src.scad_codegen import emit_program, SCADCodegenError

# numeric bins based on test_files/ast_codegen/ast.md
SIZE_BINS = [5, 10, 15, 20, 25, 30]
OFFSET_BINS = [-30, -20, -10, 0, 10, 20, 30]
ANGLE_BINS = [0, 15, 30, 45, 60, 90, 120, 180]
RADIUS_BINS = [2, 4, 6, 8, 10, 12]
HEIGHT_BINS = [5, 10, 15, 20, 25, 30]

ALL_DIR = ROOT / "dataset" / "train" / "all_openscad"
AST_DIR = ROOT / "dataset" / "train" / "ast_only"

os.makedirs(ALL_DIR, exist_ok=True)
os.makedirs(AST_DIR, exist_ok=True)

random.seed(12345)


def rand_choice(bin_list):
    return random.choice(bin_list)


def primitive_cube():
    sx = rand_choice(SIZE_BINS)
    sy = rand_choice(SIZE_BINS)
    sz = rand_choice(SIZE_BINS)
    center = random.choice([True, False])
    return {"kind": "cube", "params": {"size": [sx, sy, sz], "center": center}}


def primitive_sphere():
    r = rand_choice(RADIUS_BINS)
    return {"kind": "sphere", "params": {"r": r}}


def primitive_cylinder():
    h = rand_choice(HEIGHT_BINS)
    r = rand_choice(RADIUS_BINS)
    center = random.choice([True, False])
    return {"kind": "cylinder", "params": {"h": h, "r": r, "center": center}}


def random_primitive():
    return random.choice([primitive_cube, primitive_sphere, primitive_cylinder])()


def wrap_translate(child):
    tx = rand_choice(OFFSET_BINS)
    ty = rand_choice(OFFSET_BINS)
    tz = rand_choice(OFFSET_BINS)
    return {"kind": "translate", "params": {"offset": [tx, ty, tz]}, "child": child}


def wrap_rotate(child):
    rx = rand_choice(ANGLE_BINS)
    ry = rand_choice(ANGLE_BINS)
    rz = rand_choice(ANGLE_BINS)
    return {"kind": "rotate", "params": {"angles": [rx, ry, rz]}, "child": child}


def wrap_scale(child):
    sx = random.choice([0.5, 1.0, 1.5, 2.0])
    sy = random.choice([0.5, 1.0, 1.5, 2.0])
    sz = random.choice([0.5, 1.0, 1.5, 2.0])
    return {"kind": "scale", "params": {"factors": [sx, sy, sz]}, "child": child}


def random_transform(child):
    return random.choice([wrap_translate, wrap_rotate, wrap_scale])(child)


def random_csg(kind, depth, max_children=4):
    # difference requires at least 2 children per AST spec
    n = random.randint(1, max_children) if kind != "difference" else random.randint(2, max_children)
    children = [random_node(depth - 1) for _ in range(n)]
    return {"kind": kind, "children": children}


def random_node(depth=3):
    # depth controls nesting; primitives are leaf nodes
    if depth <= 0:
        return random_primitive()
    choice = random.random()
    if choice < 0.4:
        return random_primitive()
    elif choice < 0.7:
        child = random_node(depth - 1)
        return random_transform(child)
    else:
        kind = random.choice(["union", "difference", "intersection"])
        return random_csg(kind, depth - 1)


def emit_and_write(node, path: Path):
    program = {"root": node}
    try:
        src = emit_program(program)
    except SCADCodegenError as e:
        print("Codegen error for node:", e)
        raise
    # add header comment to improve variety and traceability
    header = f"// Generated by generate_scads.py\n"
    src = header + src
    path.write_text(src, encoding="utf-8")


def generate_folder(folder: Path, count: int, ast_only: bool = False):
    """Generate `count` unique SCAD files into `folder`.

    Notes:
        - The generator creates AST-conformant programs (only primitives,
          transforms, and CSG), guaranteeing they are serializable via the
          AST -> OpenSCAD path described in test_files/ast_codegen/ast.md.
        - `ast_only` is provided for clarity; the generation strategy here
          already produces only AST-conformant programs.
    """
    seen = set()
    i = 0
    attempts = 0
    max_attempts = count * 10
    while i < count and attempts < max_attempts:
        node = random_node(depth=3)

        # canonicalize to deterministic JSON key (ensures uniqueness)
        def canonicalize(n):
            kind = n.get("kind")
            n2 = {"kind": kind}
            if kind in {"cube", "sphere", "cylinder"}:
                n2["params"] = n["params"].copy()
            elif kind in {"translate", "rotate", "scale"}:
                n2["params"] = n["params"].copy()
                n2["child"] = canonicalize(n["child"])
            elif kind in {"union", "difference", "intersection"}:
                n2["children"] = [canonicalize(c) for c in n["children"]]
            else:
                raise ValueError(f"Unknown kind: {kind}")
            return n2

        node_c = canonicalize(node)
        key = json.dumps(node_c, sort_keys=True)
        if key in seen:
            attempts += 1
            continue
        seen.add(key)
        i += 1
        filename = f"scad_{i:05d}.scad"
        out_path = folder / filename
        emit_and_write(node_c, out_path)

    if i < count:
        raise RuntimeError(f"Unable to generate enough unique programs (got {i})")


def main():
    print("Generating 100 programs into:", ALL_DIR)
    generate_folder(ALL_DIR, 100, ast_only=False)
    print("Generating 100 AST-only programs into:", AST_DIR)
    generate_folder(AST_DIR, 100, ast_only=True)
    print("Done.")


if __name__ == "__main__":
    main()